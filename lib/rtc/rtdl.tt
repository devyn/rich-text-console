require 'treetop'
require 'cgi' # for escapeHTML

module RichTextConsole
  grammar RTDL
    rule document
      "" tags:tag+ {
        # compile it all into an intermediate format.
        def compile
          tags.elements.map { |t| t.represent }
        end
        # make it into HTML, primarily for a WebKit interface.
        def html
          depth = 0
          s = ""
          compile.each do |sg|
            case sg
            when Hash
              sty = ""
              sg.each do |k,v|
                case k
                when 'fc'
                  sty << "color:##{v.to_i(16).to_s(16)};"
                when 'bc'
                  sty << "background-color:##{v.to_i(16).to_s(16)};"
                when 'b'
                  sty << "font-weight:bold;"
                when 'i'
                  sty << "font-style:italic;"
                when 'u'
                  sty << "text-decoration:underline;"
                when 'fs'
                  sty << "font-size:#{v.to_i}pt;"
                end
              end
              s << "<span style=\"#{sty}\">"
              depth += 1
            when :end
              s << "</span>" unless depth < 1
            when :reset
              s << "</span>"*depth
            else
              s << CGI.escapeHTML(sg).gsub("\n", "<br/>")
            end
          end
          return s
        end
        # write to a Shoes flow (can be an app, too)
        def shoes(flow, global_style=nil)
          global_style ||= {:family => "monospace", :margin => 0}
          cstyle = global_style.dup
          styles = []
          update_style = proc { cstyle = global_style.dup; styles.each {|sty| cstyle = cstyle.update(sty) } }
          compile.each do |sg|
            case sg
            when Hash
              styles << {}
              sg.each do |k,v|
                case k
                when 'fc'
                  styles[-1][:stroke] = "##{v.to_i(16).to_s(16)}"
                when 'bc'
                  styles[-1][:fill] = "##{v.to_i(16).to_s(16)}"
                when 'b'
                  styles[-1][:weight] = 'bold'
                when 'i'
                  styles[-1][:emphasis] = 'italic'
                when 'u'
                  styles[-1][:undercolor] = st[:stroke]||cstyle[:stroke]||"#000000"
                when 'fs'
                  styles[-1][:size] = v.to_i
                end
              end
              update_style.call
            when :end
              styles.delete_at -1
              update_style.call
            when :reset
              styles = []
              update_style.call
            else
              flow.para sg, cstyle
            end
          end
          return flow
        end
      }
    end
    rule tag
      "\e[" "/" "]" {
        def represent
          :end
        end
      } /
      "\e[" "//" "]" {
        def represent
          :reset
        end
      } /
      "\e[" options:(option (',' &option / ""))+ "]" {
        def represent
          Hash[options.elements.map {|o| o.option.pair }]
        end
      } /
      ("\e" / [^\e\n]* "\n" / [^\e]+) {
        def represent
          text_value
        end
      }
    end
    rule option
      name:[A-Za-z]+ "=" value:[^,\]]* {
        def pair
          [name.text_value, value.text_value]
        end
      } /
      [A-Za-z]+ {
        def pair
          [text_value, nil]
        end
      }
    end
  end
end
