require 'treetop'
require 'cgi' # for escapeHTML

module RichTextConsole
  grammar RTDL
    rule document
      "" tags:tag+ {
        # compile it all into an intermediate format.
        def compile
          tags.elements.map { |t| t.represent }
        end
        # make it into HTML, primarily for a WebKit interface.
        def html
          depth = 0
          s = ""
          compile.each do |sg|
            case sg
            when Hash
              sty = ""
              sg.each do |k,v|
                case k
                when 'fc'
                  sty << "color:##{v.to_i(16).to_s(16)};"
                when 'bc'
                  sty << "background-color:##{v.to_i(16).to_s(16)};"
                when 'b'
                  sty << "font-weight:bold;"
                when 'i'
                  sty << "font-style:italic;"
                when 'u'
                  sty << "text-decoration:underline;"
                when 'fs'
                  sty << "font-size:#{v.to_i}pt;"
                end
              end
              s << "<span style=\"#{sty}\">"
              depth += 1
            when :end
              s << "</span>" unless depth < 1
            when :reset
              s << "</span>"*depth
            else
              s << CGI.escapeHTML(sg).gsub("\n", "<br/>")
            end
          end
          return s
        end
        # write to a Shoes flow (can be an app, too)
        def shoes(flow)
          unless flow.respond_to?(:rtc) and flow.respond_to?(:rtc=)
            class << flow
              attr_accessor :rtc
            end
          end
          flow.rtc         ||= {}
          flow.rtc[:gst]   ||= {:family => "monospace", :margin => 0}
          flow.rtc[:style] ||= flow.rtc[:gst].dup
          flow.rtc[:stack] ||= []
          update_style = proc { flow.rtc[:style] = flow.rtc[:gst].dup; flow.rtc[:stack].each {|sty| flow.rtc[:style].update(sty) } }
          compile.each do |sg|
            case sg
            when Hash
              flow.rtc[:stack] << (st = {})
              sg.each do |k,v|
                case k
                when 'fc'
                  st[:stroke] = "##{v.to_i(16).to_s(16)}"
                when 'bc'
                  st[:fill] = "##{v.to_i(16).to_s(16)}"
                when 'b'
                  st[:weight] = 'bold'
                when 'i'
                  st[:emphasis] = 'italic'
                when 'u'
                  st[:undercolor] = st[:stroke]||cstyle[:stroke]||"#000000"
                when 'fs'
                  st[:size] = v.to_i
                end
              end
              update_style.call
            when :end
              flow.rtc[:stack].delete_at -1
              update_style.call
            when :reset
              flow.rtc[:stack] = []
              update_style.call
            else
              flow.para sg, flow.rtc[:style]
            end
          end
          return flow
        end
      }
    end
    rule tag
      "\e[" "/" "]" {
        def represent
          :end
        end
      } /
      "\e[" "//" "]" {
        def represent
          :reset
        end
      } /
      "\e[" options:(option (',' &option / ""))+ "]" {
        def represent
          Hash[options.elements.map {|o| o.option.pair }]
        end
      } /
      ("\e" / [^\e\n]* "\n" / [^\e]+) {
        def represent
          text_value
        end
      }
    end
    rule option
      name:[A-Za-z]+ "=" value:[^,\]]* {
        def pair
          [name.text_value, value.text_value]
        end
      } /
      [A-Za-z]+ {
        def pair
          [text_value, nil]
        end
      }
    end
  end
end
